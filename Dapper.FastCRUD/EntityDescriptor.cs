namespace Dapper.FastCrud
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using System.Threading;
    using Dapper.FastCrud.Mappings;
    using Dapper.FastCrud.SqlBuilders;
    using Dapper.FastCrud.SqlStatements;

    internal class EntityDescriptor
    {
        private IDictionary<EntityMapping, ISqlStatements> _registeredEntityMappings = new Dictionary<EntityMapping, ISqlStatements>();

        // this can be set by the developer, prior to making any sql statement calls
        // alternatively it is set by us on first usage
        private volatile EntityMapping _defaultEntityMapping = null;

        public EntityMapping DefaultEntityMapping
        {
            get
            {
                return _defaultEntityMapping;
            }
            set
            {
                _defaultEntityMapping = value;
            }
        }

        /// <summary>
        /// Returns the sql statements for an entity mapping, or the default one if the argument is null.
        /// If none is present, an auto-generated mapping will be constructed and registered.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ISqlStatements GetSqlStatements<TEntity>(EntityMapping entityMapping = null)
        {
            // set the default entity mapping if not already set
            if (_defaultEntityMapping == null)
            {
                _defaultEntityMapping = entityMapping ?? new AutoGeneratedEntityMapping<TEntity>();
            }

            entityMapping = entityMapping ?? _defaultEntityMapping;

            ISqlStatements sqlStatements;
            var originalRegisteredEntityMappings = _registeredEntityMappings;
            if (!originalRegisteredEntityMappings.TryGetValue(entityMapping, out sqlStatements))
            {
                switch (entityMapping.Dialect)
                {
                    case SqlDialect.MsSql:
                        sqlStatements = new GenericSqlStatements<TEntity>(new MsStatementSqlBuilder(entityMapping));
                        break;
                    case SqlDialect.MySql:
                        sqlStatements = new GenericSqlStatements<TEntity>(new MySqlBuilder(entityMapping));
                        break;
                    case SqlDialect.PostgreSql:
                        sqlStatements = new GenericSqlStatements<TEntity>(new PostgreStatementSqlBuilder(entityMapping));
                        break;
                    case SqlDialect.SqLite:
                        sqlStatements = new GenericSqlStatements<TEntity>(new SqLiteBuilder(entityMapping));
                        break;
                    default:
                        throw new NotSupportedException($"Dialect {entityMapping.Dialect} is not supported");
                }

                entityMapping.IsFrozen = true;

                Interlocked.Exchange(
                    ref _registeredEntityMappings,
                    new Dictionary<EntityMapping, ISqlStatements>(originalRegisteredEntityMappings) { [entityMapping] = sqlStatements });
            }
            return sqlStatements;
        }
    }
}
