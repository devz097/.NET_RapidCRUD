namespace Dapper.FastCrud.EntityDescriptors
{
    using System;
    using System.Collections.Concurrent;
    using System.Diagnostics;
    using System.Threading;
    using Dapper.FastCrud.Mappings;
    using Dapper.FastCrud.SqlBuilders;
    using Dapper.FastCrud.SqlStatements;

    /// <summary>
    /// Typed entity descriptor, capable of producing statement builders associated with default entity mappings.
    /// </summary>
    internal class EntityDescriptor<TEntity>:EntityDescriptor
    {
        private static readonly long _cleanupTimespan = TimeSpan.Zero.Ticks;
        private readonly Stopwatch _lastCleanupTime;

        // entity mappings should have a very long timespan if used correctly, however we can't make that assumption
        // hence we'll cache them for the duration of their lifespan and clean them up periodically
        private readonly ConcurrentDictionary<Guid, Tuple<WeakReference<EntityMapping>,  ISqlStatements>> _registeredEntityMappings;
        private readonly Lazy<ISqlStatements> _defaultEntityMappingSqlStatements;

        /// <summary>
        /// Default constructor
        /// </summary>
        public EntityDescriptor()
            :base(typeof(TEntity))
        {
            this.DefaultEntityMapping = new AutoGeneratedEntityMapping<TEntity>();
            _registeredEntityMappings = new ConcurrentDictionary<Guid, Tuple<WeakReference<EntityMapping>, ISqlStatements>>();
            _defaultEntityMappingSqlStatements = new Lazy<ISqlStatements>(()=>this.ConstructSqlStatements(this.DefaultEntityMapping), LazyThreadSafetyMode.PublicationOnly);
            _lastCleanupTime = new Stopwatch();
            _lastCleanupTime.Start();
        }

        /// <summary>
        /// Returns the sql statements for an entity mapping, or the default one if the argument is null.
        /// </summary>
        public ISqlStatements GetSqlStatements(EntityMapping entityMapping = null)
        {
            ISqlStatements sqlStatements;
            // default entity mappings are the ones that are mostly used, treat them differently
            if (entityMapping == null)
            {
                sqlStatements = _defaultEntityMappingSqlStatements.Value;
            }
            else
            {
                var cachedStatements = _registeredEntityMappings.GetOrAdd(entityMapping.Id, mappingId => new Tuple<WeakReference<EntityMapping>, ISqlStatements>(new WeakReference<EntityMapping>(entityMapping), this.ConstructSqlStatements(entityMapping)));
                sqlStatements = cachedStatements.Item2;
                if (_lastCleanupTime.ElapsedTicks > _cleanupTimespan)
                {
                    // we might hit this multiple times until we reset the counter, but that only means we'll perform the cleanup multiple times
                    _lastCleanupTime.Restart();
                    ThreadPool.UnsafeQueueUserWorkItem(state => this.CleanupOrphanEntityMappings(), null);
                }
            }

            return sqlStatements;
        }

        private ISqlStatements ConstructSqlStatements(EntityMapping entityMapping)
        {
            entityMapping.FreezeMapping();

            ISqlStatements sqlStatements;
            IStatementSqlBuilder statementSqlBuilder;

            switch (entityMapping.Dialect)
            {
                case SqlDialect.MsSql:
                    statementSqlBuilder = new MsSqlBuilder(this, entityMapping);
                    break;
                case SqlDialect.MySql:
                    statementSqlBuilder = new MySqlBuilder(this, entityMapping);
                    break;
                case SqlDialect.PostgreSql:
                    statementSqlBuilder = new PostgreSqlBuilder(this, entityMapping);
                    break;
                case SqlDialect.SqLite:
                    statementSqlBuilder = new SqLiteBuilder(this, entityMapping);
                    break;
                default:
                    throw new NotSupportedException($"Dialect {entityMapping.Dialect} is not supported");
            }

            sqlStatements = new GenericSqlStatements<TEntity>(statementSqlBuilder);
            return sqlStatements;
        }

        private void CleanupOrphanEntityMappings()
        {
            EntityMapping dummyEntityMapping;
            Tuple<WeakReference<EntityMapping>, ISqlStatements> dummySqlStatements;
            foreach (var cachedMappingStatements in _registeredEntityMappings)
            {
                //if (!cachedMappingStatements.Value.Item1.TryGetTarget(out dummyEntityMapping))
                {
                    _registeredEntityMappings.TryRemove(cachedMappingStatements.Key, out dummySqlStatements);
                }
            }
        }
    }
}
